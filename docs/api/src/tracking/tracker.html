<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>src.tracking.tracker API documentation</title>
<meta name="description" content="Tracking module for license plate tracking with OCR trigger logic …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.tracking.tracker</code></h1>
</header>
<section id="section-intro">
<p>Tracking module for license plate tracking with OCR trigger logic.</p>
<p>This module implements the PlateTrack class which manages the state of tracked
license plates and determines when OCR should be performed based on configurable
criteria defined in shrimp-rules.md.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.tracking.tracker.PlateTrack"><code class="flex name class">
<span>class <span class="ident">PlateTrack</span></span>
<span>(</span><span>track_id: int, bbox: Tuple[int, int, int, int], confidence: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlateTrack:
    &#34;&#34;&#34;
    Manages the state and lifecycle of a tracked license plate.

    This class maintains all information about a tracked plate including its
    bounding box, detection confidence, OCR results, and timing information
    for intelligent OCR triggering.

    Attributes:
        id (int): Unique track identifier assigned by ByteTrack
        bbox (Tuple[int, int, int, int]): Bounding box coordinates (x1, y1, x2, y2)
        detection_confidence (float): Latest detection confidence score
        text (Optional[str]): Recognized plate text (None if not yet recognized)
        ocr_confidence (float): Confidence score from OCR recognition
        age (int): Number of frames since track was first detected
        frames_since_last_ocr (int): Frames elapsed since last OCR run
        is_active (bool): Whether track is currently active (not lost)
    &#34;&#34;&#34;

    def __init__(self, track_id: int, bbox: Tuple[int, int, int, int], confidence: float):
        &#34;&#34;&#34;
        Initialize a new plate track.

        Args:
            track_id: Unique identifier for this track
            bbox: Initial bounding box (x1, y1, x2, y2)
            confidence: Initial detection confidence score
        &#34;&#34;&#34;
        self.id = track_id
        self.bbox = bbox
        self.detection_confidence = confidence
        self.text: Optional[str] = None
        self.ocr_confidence: float = 0.0
        self.age: int = 0  # Frames since first detection
        self.frames_since_last_ocr: int = 0
        self.is_active: bool = True

    def update(self, bbox: Tuple[int, int, int, int], confidence: float) -&gt; None:
        &#34;&#34;&#34;
        Update track with new detection information.

        This method is called every frame when the track is successfully detected
        by the tracker. It updates the bounding box, confidence, and increments
        frame counters.

        Args:
            bbox: Updated bounding box coordinates (x1, y1, x2, y2)
            confidence: Updated detection confidence score
        &#34;&#34;&#34;
        self.bbox = bbox
        self.detection_confidence = confidence
        self.age += 1
        self.frames_since_last_ocr += 1

    def update_text(self, text: Optional[str], confidence: float) -&gt; None:
        &#34;&#34;&#34;
        Update track with OCR recognition results.

        This method is called after OCR is performed on the tracked plate.
        It stores the recognized text and confidence, and resets the OCR timer.

        Args:
            text: Recognized plate text (None if recognition failed)
            confidence: OCR confidence score (0.0 if recognition failed)
        &#34;&#34;&#34;
        self.text = text
        self.ocr_confidence = confidence
        self.frames_since_last_ocr = 0

    def should_run_ocr(self, config: dict) -&gt; bool:
        &#34;&#34;&#34;
        Determine whether OCR should be run for this track based on decision rules.

        This method implements the OCR trigger logic defined in shrimp-rules.md:

        1. New track detected (age == 0) → Always run OCR
        2. Stale recognition (frames_since_last_ocr &gt;= ocr_interval) → Run OCR to refresh
        3. Low confidence retry (ocr_confidence &lt; threshold) → Run OCR to improve
        4. High detection confidence + no text → Run OCR for strong detections
        5. Track lost (is_active == False) → Never run OCR (handled by caller)

        Args:
            config: Tracking configuration dictionary containing:
                - ocr_interval: Maximum frames between OCR runs (default: 30)
                - ocr_confidence_threshold: Minimum acceptable confidence (default: 0.7)

        Returns:
            bool: True if OCR should be run, False otherwise
        &#34;&#34;&#34;
        # Condition 1: New track (age 0) - always recognize immediately
        if self.age == 0:
            return True

        # Condition 2: Refresh stale recognition
        ocr_interval = config.get(&#34;ocr_interval&#34;, 30)
        if self.frames_since_last_ocr &gt;= ocr_interval:
            return True

        # Condition 3: Low confidence, retry to improve recognition
        threshold = config.get(&#34;ocr_confidence_threshold&#34;, 0.7)
        if self.text is not None and self.ocr_confidence &lt; threshold:
            return True

        # Condition 4: High detection confidence but no text yet
        # This catches cases where we have a strong detection but haven&#39;t recognized yet
        if self.detection_confidence &gt; 0.9 and self.text is None:
            return True

        return False

    def mark_lost(self) -&gt; None:
        &#34;&#34;&#34;
        Mark this track as lost (no longer actively tracked).

        This is called when ByteTrack determines the track has been lost.
        Once lost, OCR should not be run on this track (enforced by caller).
        &#34;&#34;&#34;
        self.is_active = False

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;String representation for debugging.&#34;&#34;&#34;
        status = &#34;active&#34; if self.is_active else &#34;lost&#34;
        text_display = f&#34;&#39;{self.text}&#39;&#34; if self.text else &#34;None&#34;
        return (
            f&#34;PlateTrack(id={self.id}, age={self.age}, &#34;
            f&#34;text={text_display}, conf={self.ocr_confidence:.2f}, &#34;
            f&#34;status={status})&#34;
        )</code></pre>
</details>
<div class="desc"><p>Manages the state and lifecycle of a tracked license plate.</p>
<p>This class maintains all information about a tracked plate including its
bounding box, detection confidence, OCR results, and timing information
for intelligent OCR triggering.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>Unique track identifier assigned by ByteTrack</dd>
<dt><strong><code>bbox</code></strong> :&ensp;<code>Tuple[int, int, int, int]</code></dt>
<dd>Bounding box coordinates (x1, y1, x2, y2)</dd>
<dt><strong><code>detection_confidence</code></strong> :&ensp;<code>float</code></dt>
<dd>Latest detection confidence score</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Recognized plate text (None if not yet recognized)</dd>
<dt><strong><code>ocr_confidence</code></strong> :&ensp;<code>float</code></dt>
<dd>Confidence score from OCR recognition</dd>
<dt><strong><code>age</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of frames since track was first detected</dd>
<dt><strong><code>frames_since_last_ocr</code></strong> :&ensp;<code>int</code></dt>
<dd>Frames elapsed since last OCR run</dd>
<dt><strong><code>is_active</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether track is currently active (not lost)</dd>
</dl>
<p>Initialize a new plate track.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_id</code></strong></dt>
<dd>Unique identifier for this track</dd>
<dt><strong><code>bbox</code></strong></dt>
<dd>Initial bounding box (x1, y1, x2, y2)</dd>
<dt><strong><code>confidence</code></strong></dt>
<dd>Initial detection confidence score</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="src.tracking.tracker.PlateTrack.mark_lost"><code class="name flex">
<span>def <span class="ident">mark_lost</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_lost(self) -&gt; None:
    &#34;&#34;&#34;
    Mark this track as lost (no longer actively tracked).

    This is called when ByteTrack determines the track has been lost.
    Once lost, OCR should not be run on this track (enforced by caller).
    &#34;&#34;&#34;
    self.is_active = False</code></pre>
</details>
<div class="desc"><p>Mark this track as lost (no longer actively tracked).</p>
<p>This is called when ByteTrack determines the track has been lost.
Once lost, OCR should not be run on this track (enforced by caller).</p></div>
</dd>
<dt id="src.tracking.tracker.PlateTrack.should_run_ocr"><code class="name flex">
<span>def <span class="ident">should_run_ocr</span></span>(<span>self, config: dict) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def should_run_ocr(self, config: dict) -&gt; bool:
    &#34;&#34;&#34;
    Determine whether OCR should be run for this track based on decision rules.

    This method implements the OCR trigger logic defined in shrimp-rules.md:

    1. New track detected (age == 0) → Always run OCR
    2. Stale recognition (frames_since_last_ocr &gt;= ocr_interval) → Run OCR to refresh
    3. Low confidence retry (ocr_confidence &lt; threshold) → Run OCR to improve
    4. High detection confidence + no text → Run OCR for strong detections
    5. Track lost (is_active == False) → Never run OCR (handled by caller)

    Args:
        config: Tracking configuration dictionary containing:
            - ocr_interval: Maximum frames between OCR runs (default: 30)
            - ocr_confidence_threshold: Minimum acceptable confidence (default: 0.7)

    Returns:
        bool: True if OCR should be run, False otherwise
    &#34;&#34;&#34;
    # Condition 1: New track (age 0) - always recognize immediately
    if self.age == 0:
        return True

    # Condition 2: Refresh stale recognition
    ocr_interval = config.get(&#34;ocr_interval&#34;, 30)
    if self.frames_since_last_ocr &gt;= ocr_interval:
        return True

    # Condition 3: Low confidence, retry to improve recognition
    threshold = config.get(&#34;ocr_confidence_threshold&#34;, 0.7)
    if self.text is not None and self.ocr_confidence &lt; threshold:
        return True

    # Condition 4: High detection confidence but no text yet
    # This catches cases where we have a strong detection but haven&#39;t recognized yet
    if self.detection_confidence &gt; 0.9 and self.text is None:
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Determine whether OCR should be run for this track based on decision rules.</p>
<p>This method implements the OCR trigger logic defined in shrimp-rules.md:</p>
<ol>
<li>New track detected (age == 0) → Always run OCR</li>
<li>Stale recognition (frames_since_last_ocr &gt;= ocr_interval) → Run OCR to refresh</li>
<li>Low confidence retry (ocr_confidence &lt; threshold) → Run OCR to improve</li>
<li>High detection confidence + no text → Run OCR for strong detections</li>
<li>Track lost (is_active == False) → Never run OCR (handled by caller)</li>
</ol>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Tracking configuration dictionary containing:
- ocr_interval: Maximum frames between OCR runs (default: 30)
- ocr_confidence_threshold: Minimum acceptable confidence (default: 0.7)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if OCR should be run, False otherwise</dd>
</dl></div>
</dd>
<dt id="src.tracking.tracker.PlateTrack.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, bbox: Tuple[int, int, int, int], confidence: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, bbox: Tuple[int, int, int, int], confidence: float) -&gt; None:
    &#34;&#34;&#34;
    Update track with new detection information.

    This method is called every frame when the track is successfully detected
    by the tracker. It updates the bounding box, confidence, and increments
    frame counters.

    Args:
        bbox: Updated bounding box coordinates (x1, y1, x2, y2)
        confidence: Updated detection confidence score
    &#34;&#34;&#34;
    self.bbox = bbox
    self.detection_confidence = confidence
    self.age += 1
    self.frames_since_last_ocr += 1</code></pre>
</details>
<div class="desc"><p>Update track with new detection information.</p>
<p>This method is called every frame when the track is successfully detected
by the tracker. It updates the bounding box, confidence, and increments
frame counters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bbox</code></strong></dt>
<dd>Updated bounding box coordinates (x1, y1, x2, y2)</dd>
<dt><strong><code>confidence</code></strong></dt>
<dd>Updated detection confidence score</dd>
</dl></div>
</dd>
<dt id="src.tracking.tracker.PlateTrack.update_text"><code class="name flex">
<span>def <span class="ident">update_text</span></span>(<span>self, text: str | None, confidence: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_text(self, text: Optional[str], confidence: float) -&gt; None:
    &#34;&#34;&#34;
    Update track with OCR recognition results.

    This method is called after OCR is performed on the tracked plate.
    It stores the recognized text and confidence, and resets the OCR timer.

    Args:
        text: Recognized plate text (None if recognition failed)
        confidence: OCR confidence score (0.0 if recognition failed)
    &#34;&#34;&#34;
    self.text = text
    self.ocr_confidence = confidence
    self.frames_since_last_ocr = 0</code></pre>
</details>
<div class="desc"><p>Update track with OCR recognition results.</p>
<p>This method is called after OCR is performed on the tracked plate.
It stores the recognized text and confidence, and resets the OCR timer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>Recognized plate text (None if recognition failed)</dd>
<dt><strong><code>confidence</code></strong></dt>
<dd>OCR confidence score (0.0 if recognition failed)</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.tracking" href="index.html">src.tracking</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.tracking.tracker.PlateTrack" href="#src.tracking.tracker.PlateTrack">PlateTrack</a></code></h4>
<ul class="">
<li><code><a title="src.tracking.tracker.PlateTrack.mark_lost" href="#src.tracking.tracker.PlateTrack.mark_lost">mark_lost</a></code></li>
<li><code><a title="src.tracking.tracker.PlateTrack.should_run_ocr" href="#src.tracking.tracker.PlateTrack.should_run_ocr">should_run_ocr</a></code></li>
<li><code><a title="src.tracking.tracker.PlateTrack.update" href="#src.tracking.tracker.PlateTrack.update">update</a></code></li>
<li><code><a title="src.tracking.tracker.PlateTrack.update_text" href="#src.tracking.tracker.PlateTrack.update_text">update_text</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
